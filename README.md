# test_tasks

### task1
В данном задании я решил реализовать по 2 подхода в для каждого из языков `Python` и `C++`. 

### Вариант 1
Первый подход (функции `isEven` и `is_even`) основан на том факте, что любое число, кратное 10, также кратно и 2. Таким образом, нам достаточно просто проверить кратность последней цифры этого числа. При этом взятие последний цифры числа основано на преобразовании числа в сроку и взятии последнего элемента данной строки.

**Преимущества**

Плюсом данного подхода является то, что данная операция не зависит от величины входного числа. Это число может даже не влезать в стандартные типы в `C++`, но мы по-прежнему можем проверить четность этого числа. В `Python` проблемы с переполнением типов не возникает, т.к. длинная арифметика встроена в язык. У этого подхода есть еще один большой плюс - данный алгоритм работает одинаково быстро для чисел любого размера (если не брать во внимание операцию перевода числа в строку), т.к. не происходит фактического деления числа, а делится только одна цифра.

**Недостатки**

Минусами этого алгоритма являются затраты на перевод числа в строку и память, выделяемая для хранения строки. При небольших числах иногда быстрее просто честно найти остаток от деления всего числа на 2, чем переводить все число в строку и делать те же операции с последней цифрой. Также, может увеличиться занимаемая память. Например, в `C++` тип `char` занимает 1 байт, а тип `int` - 4 байта. При этом `int` позволяет хранить десятизначные числа. Однако, десятизначное число в строковом виде будет занимать уже 10 байт.

### Вариант 2

Второй подход (функции `isEvenBinary` и `is_even_binary`) основан на использовании битовых операций. При применении побитового "и" (оператор `&`) исходного числа с 1 происходит следующее: выполняется конъюнкция для всех битов входного числа с соответствующими битами 1, но у 1 все биты, кроме последнего, равны 0. Таким образом, результатом выполнения это операции (`value & 1`) последний бит числа `value`. И остается проверить равен он 1 или 0 (у четных чисел последний бит равен 0). 

**Преимущества**

Плюсом данного подхода является его скорость, поскольку битовые операции выполняются быстрее, чем привычные арифметические операции, поскольку являются более низкоуровневыми и близкими к процессору. Также, преимуществом является лаконичность кода.

**Недостатки**

Минусом этого варианта яляется его непривычность для людей. Обычные арифметические операции понятны на интуитивном уровне чего нельзя сказать про побитовые операции. Это может сказаться на читабельности кода: когда в программе очень много побитовых операций и их комбинаций, то становится сложнее понять что делает этот код. Еще одним ограничением подхода (это касается `C++`) является вместимость стандартных типов языка.




В приведенных в задании реализациях плюсами являются лаконичность и читабельность кода (понятно зачем нужны эти функции, что они делают и при этом не использовано лишних манипуляций с данными). Однако, у данного подхода есть минусы: время работы программы зависит от величины числа (но в рамках стандартных типов и/или разумных чисел это не играет большой роли) и ограниченность входа стандартными типами (только для `C++`).
