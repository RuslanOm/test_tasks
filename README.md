# test_tasks

## task1
В данном задании я решил реализовать по 2 подхода в для каждого из языков `Python` и `C++`. 

### Вариант 1
Первый подход (функции `isEven` и `is_even`) основан на том факте, что любое число, кратное 10, также кратно и 2. Таким образом, нам достаточно просто проверить кратность последней цифры этого числа. При этом взятие последний цифры числа основано на преобразовании числа в сроку и взятии последнего элемента данной строки.

**Преимущества**

Плюсом данного подхода является то, что данная операция не зависит от величины входного числа. Это число может даже не влезать в стандартные типы в `C++`, но мы по-прежнему можем проверить четность этого числа. В `Python` проблемы с переполнением типов не возникает, т.к. длинная арифметика встроена в язык. У этого подхода есть еще один большой плюс - данный алгоритм работает одинаково быстро для чисел любого размера (если не брать во внимание операцию перевода числа в строку), т.к. не происходит фактического деления числа, а делится только одна цифра.

**Недостатки**

Минусами этого алгоритма являются затраты на перевод числа в строку и память, выделяемая для хранения строки. При небольших числах иногда быстрее просто честно найти остаток от деления всего числа на 2, чем переводить все число в строку и делать те же операции с последней цифрой. Также, может увеличиться занимаемая память. Например, в `C++` тип `char` занимает 1 байт, а тип `int` - 4 байта. При этом `int` позволяет хранить десятизначные числа. Однако, десятизначное число в строковом виде будет занимать уже 10 байт.

### Вариант 2

Второй подход (функции `isEvenBinary` и `is_even_binary`) основан на использовании битовых операций. При применении побитового "и" (оператор `&`) исходного числа с 1 происходит следующее: выполняется конъюнкция для всех битов входного числа с соответствующими битами 1, но у 1 все биты, кроме последнего, равны 0. Таким образом, результатом выполнения это операции (`value & 1`) последний бит числа `value`. И остается проверить равен он 1 или 0 (у четных чисел последний бит равен 0). 

**Преимущества**

Плюсом данного подхода является его скорость, поскольку битовые операции выполняются быстрее, чем привычные арифметические операции, поскольку являются более низкоуровневыми и близкими к процессору. Также, преимуществом является лаконичность кода.

**Недостатки**

Минусом этого варианта яляется его непривычность для людей. Обычные арифметические операции понятны на интуитивном уровне чего нельзя сказать про побитовые операции. Это может сказаться на читабельности кода: когда в программе очень много побитовых операций и их комбинаций, то становится сложнее понять что делает этот код. Еще одним ограничением подхода (это касается `C++`) является вместимость стандартных типов языка.




В приведенных в задании реализациях плюсами являются лаконичность и читабельность кода (понятно зачем нужны эти функции, что они делают и при этом не использовано лишних манипуляций с данными). Однако, у данного подхода есть минусы: время работы программы зависит от величины числа (но в рамках стандартных типов и/или разумных чисел это не играет большой роли) и ограниченность входа стандартными типами (только для `C++`).


## task2

В данном задании я рассмотрел 2 варианта реализации кольцевого буфера: с помощью массива фиксированного размера и 2 указателей на хвост и голову и с помощью структуры данных `deque` (она есть как в `Python`, так и в `C++`). 

В варианте реализации с помощью массива при инициализации класса создается буфер заданного размера и 2 указателя: хвост (то, куда будем вставлять элементы) и голова (то, откуда будут удаляться элементы). При добавлении и удалении элементов соответствующие указатели изменяются нужным образом. 

Во втором варианте использована структура данных `deque`, которая является обобщением для интерфейсов стека и очереди. Логика работы в данном случае упрощается: добавление элементов происходит с одной стороны, а удалении с другой. При этом, если мы достигли максимального размера буфера, то при добавлении элемента дополнительно удаляется элемент с противоположного конца. Таким образом, всегда поддерживается корректный размер буфера и его состояние.

### Вариант с массивом

**Достоинства**

К достоинствам работы с массивом можно отнести потенциальную скорость выполнения операций, поскольку при использоании массива, как правило, выделяется непрерывный кусок памяти, в котором доступ к элементам осуществляется быстрее. Также, поскольку все операции имеют константное время выполнения в худшем случае, то реализацию на массиве можно считать оптимальной.


**Недостатки**

К недостаткам данного способа относится постоянный объем занимаемой памяти под буфер. Если буфер большого размера, но данных в нем в большинство моментов времени немного, то много памяти будет занято впустую. Также, еще одним минусом является сложность работы с указателями, поскольку при разных условиях они ведут себя по-разному, и возрастает риск ошибок. 


### Вариант с deque

**Достоинства**

К достоинствам работы с deque можно отнести простоту реализации, поскольку не нужно задумываться над тем что и куда вставлять и удалять из буфера. Также, плюсом может стать то, что размер занимаемой буфером памяти зависит от количества элементов в этом буфере. Т.е. когда в буфере мало элементов, то и он сам занимает мало памяти (в отличие от жестко выделенного массива).  

**Недостатки**

Недостатком может стать использование `deque` в реализации. Все зависит от того, как реализован интерфейс `deque`: если он реализован не оптимально, то можно потерять константное время на выполнение операций удаления и вставки (возможно, оно может стать равным O(1) в среднем на одну операцию, но не исключен вариант при очень плохих реализациях - O(n) в худшем на одну операцию).


## task3

Для реализации алгоритма сортировки была выбрана сортировка слиянием. Данная сортировка работает за O(n * log n) памяти в худшем случае. К достоинствам данного способа сортировки можно отнести отсутствие "плохих" входов для нее: она одинаково работает как на почти сортированных данных, так и на случаных данных (чего нельзя сказать, например, про быструюу сортировку, которая деградирует на плохих входах до O(n^2)). Также, данная сортировка является устойчивой, т.е. сохраняет относительный порядок равных элементов, в котором они были в исходном массиве. Про сортировки, которые основаны на сравнениях элементов, доказано, что минимальное время, необходимое для сортировки входа размера n с помощью сравнений - это как раз O(n * log n), т.е. сортировка слиянием в данном смысле является оптимальной (если мы рассматриваем абсолютно любые входные данные). 
Также можно было рассмотреть сортировку подсчетом, которая работает за O(n + max a), где max a - модуль максимального элемента в массиве. Но данная сортировка предпочтительнее только в том случае, когда элементы массива небольшие по модулю и, соотвественно, часто повторяются (при больших n), но по условию задачи это не так, поэтому этот вариант отпадает.

Стоит, также, отметить, что в приведенной реализации (файл `task3.py`) можно сортировать не только числа, но и любые объекты, для которых каким-либо образом определена функция `comp` (в том числе, числа можно отсортировать в обратном порядке). 






